// Minecraft: CS30 Edition Beta 0.1
// Brayden Griffith
// Date
//3/5/2024 (d/m/y)
// Extra for Experts:
// - I use a three-dimensional array called oldGrid that I use to store 32 2D arrays.
// - I use "undefined" as boolean value in if statements to check properties.




//the grid currently displayed
let grid;
//dependent on const GRID_SIZE
let cellSize;
//the block that the player is currently holding. Identified by block ID.
let blockSelected;
//dummy variable so that if statements don't throw an error by being empty. It's called "dummy" because it's a dummy variable.
let dummy = true;
//Tracks the z-level the player is on/going to
let zLevel = 32;
//Tracks the z-level the player is on/used to be on (until the new grid loads)
let oldZ = 32;
//Tracks the state of the crafting menu.
let craftingState = "None";
//Facilitates closing and opening the menu.
let menuState = "open";
//Facilitates complex crafting when in range of a workshop, held in "workshops[]".
let workshopCraft = false;
//The last slot in the inventory UI.
let lastSlot;
//Unused? I'm too afraid to delete it.
let pigCounter = 0;
//Controls if its on the menu screen or in the game
let startMenuState = true;
//Controls the tiles you walk on and if the old tiles transform into open tiles or wooden floors
let tileState = "open tile"
//Sets to true if the player JUST fell in lava, displays death message while true.
let playerDeathState = false;
//built-in class that facilitates writing a txt file
let writer;

//Arrays storing coordinates of where cieling holes should be AFTER floor holes are generated on the layer above it.
//while generating grid, it uses the oldCielingHoleLocationX and Y arrays to check for holes generated by previous layer.
//newCielingHoleLocationX and Y are the variables that hold the new values generated by the layer, turns into old version at the end
//of the function.
let oldCielingHoleLocationX = [];
let oldCielingHoleLocationY = [];
let newCielingHoleLocationX = [];
let newCielingHoleLocationY = [];

//The 3D array which stores all 2D arrays
let oldGrid = [];

//The array which holds locations of all workshops in the 3D array. When in range, allows the player to craft
//with workshop.
let workshops = [];

//Stores 3 class objects in the array
let pigs = [];

//How many tiles across the grid is
const GRID_SIZE = 30;

//Rest are block IDs
const PLAYER = 9;
const OPEN_TILE = 0;
const STONE = 1;
const FLOOR_HOLE_TILE = 2;
const CIELING_HOLE_TILE = 3;
const PLANK = 4;
const TREE = 5;
const PIG = 6;
const HELLCRAWLER = 7;
const GOBLIN = 8;
const IRON = 10;
const GOLD = 11;
const ADAM = 12;
const COAL = 13;
const WORKSHOP = 14;
const DOOR = 15;
const LAVA = 16;
const STONE_BRICKS = 18;
const WOODEN_FLOOR = 19;

//controls how often trees spawn
const TREE_SR = 30000;

//controls how many trees can be on the grid (top z level)
const MAX_TREES = 20;

const PIG_SR = 40000;
const MAX_PIGS = 2; //Note that the const MAX_PIGS signifies the maximum number of pigs to include a 0th pig
//(uses in for loop where i = 0; i<MAX_PIGS; i++)
const PIG_IDLE_TIME = 3000;

//keeps track of player position
let player = {
  x: 0,
  y: 0,
};

//Keeps track of timer-focused variables
let timePassed  = {
  trees: 0,
  pigs: 0
};

//Gives you the values in your inventory
let inventory = {
  stoneCollected: 0,
  logsCollected: 10,
  porkCollected: 0,
  porkchopCollected: 0,
  burntFleshCollected: 0,
  fleshCollected: 0,
  ironOreCollected: 0,
  ironCollected: 0,
  goldOreCollected: 0,
  goldCollected: 0,
  adamantiumOreCollected: 0,
  adamantiumCollected: 0,
  coalCollected: 0,
  workshopsCollected: 0,
  doorsCollected: 0,
  spikesCollected: 0,
  woodenSwordCollected: 0,
  woodenPickaxeCollected: 0,
  stoneSwordCollected: 0,
  stonePickaxeCollected: 0,
  ironPickaxeCollected: 0,
  ironSwordCollected: 0,
  ironArmorCollected: 0,
  adamantiumPickaxeCollected: 0,
  adamantiumSwordCollected: 0,
  adamantiumArmorCollected: 0,
  amuletCollected: 0,
  crucibleCollected: 0,
  stoneBricksCollected: 0,
  woodenFlooringCollected: 0
};

//In the event of death, your current inventory will be set to the same values within this one.
let emptyInventory = {
  stoneCollected: 0,
  logsCollected: 0,
  porkCollected: 0,
  porkchopCollected: 0,
  burntFleshCollected: 0,
  fleshCollected: 0,
  ironOreCollected: 0,
  ironCollected: 0,
  goldOreCollected: 0,
  goldCollected: 0,
  adamantiumOreCollected: 0,
  adamantiumCollected: 0,
  coalCollected: 0,
  workshopsCollected: 0,
  doorsCollected: 0,
  spikesCollected: 0,
  woodenSwordCollected: 0,
  woodenPickaxeCollected: 0,
  stoneSwordCollected: 0,
  stonePickaxeCollected: 0,
  ironPickaxeCollected: 0,
  ironSwordCollected: 0,
  ironArmorCollected: 0,
  adamantiumPickaxeCollected: 0,
  adamantiumSwordCollected: 0,
  adamantiumArmorCollected: 0,
  amuletCollected: 0,
  crucibleCollected: 0,
  stoneBricksCollected: 0,
  woodenFlooringCollected: 0
}


class Pig {
constructor(x, y, pigNumber) {
  //Location the pig should theoretically be on
  this.oldX = x;
  this.oldY = y;
  //Location the pig is heading to next
  this.x = x;
  this.y = y;
  //Not sure why I need this but it breaks without it.
  this.movementSpeed = 0;
  //Combined in use with millis() and PIG_IDLE_TIME, designates when a pig should move.
  this.pigPassiveMovement = 0;
  //Keeps track of the health of the pig in question.
  this.health = 7;
  //Keeps track if the pig's health reaches 0 or below. Becomes true if yes.
  this.deathState = false;
  //Designed to stop the pig from moving when it reaches zero health before it dies.
  this.moveState = true;
  //The pig's ID that it keeps track of with the popGood() function that Hanson made (special thanks to him)
  this.pigNumber = pigNumber;
}
move() {
  //random movement if not dead
  if(this.moveState = true) {
    let choice = random(100);
    if (choice > 75 && this.x<GRID_SIZE) {
      this.x++;
    }
    else if (choice > 50 && this.x>0) {
      this.x--;
    }
    else if (choice > 25 && this.y<GRID_SIZE) {
      this.y++;
    }
    else if (choice > 0 && this.y>0){
      this.y--;
    }
  }
  
}

passiveMovement() {
  //Makes a timer. When the timer goes off, make the pig move and move the time it takes to make a new one to
  //the current time + the constant PIG_IDLE_TIME with 0.1 seconds extra give or take. Then when the timer
  //catches up, repeat the first step.
  if (millis() > this.pigPassiveMovement) {
    if (millis() > this.movementSpeed) {
      this.move();
      this.pigPassiveMovement = millis()+PIG_IDLE_TIME+random(100);
      
    }

  }
}
//Runs through before every time the pig must move, but only activates if the health of the pig drops below
//0 HP.
die() {
  if (this.deathState === true && (this === pigs[this.pigNumber])) {
    //Sets the tile the pig was occupying to an open tile.
    grid[this.y][this.x] = 0;
    //Makes it so it can't move come the iteration of the next function
    this.moveState = false;
    //Checks if this is the correct pig to pop from the array as a safety measure, since it checks multiple
    //times per second whether to make pigs die or not.
    if (pigs[this.pigNumber].pigNumber === this.pigNumber){
      //If so, creates a new array where the shuffle their ID. The pig slated for death loses its spot in the new
      //array and the other pigs go down a position, allowing a new pig to spawn. Then replaces the old array with the
      //new one.
      pigs = this.popGood(this.pigNumber, pigs)
    }
  }
}
//See above exxplanation.
popGood(numberToPop, array){
  let arrayFinal = [];
  for (let i = 0; i < array.length; i++){
    if (i !== numberToPop){
      arrayFinal.push(array[i])
    }
  }
  return arrayFinal;
}

}

//Establishes all game sprites and sound effects used as variables.
let grassImg;
let treeImg;
let plankImg;
let gravelImg;
let stoneImg;
let dirtBGImg;
let logoImg;
let ambientBGM;
let woodenFloorImg;
let stoneBrickImg;
let woodWalkSFX1;
let woodWalkSFX2;
let stoneWalkSFX1;
let stoneWalkSFX2;
let grassWalkSFX1;
let grassWalkSFX2;
let woodySFX;
let stoneySFX;
let clickSFX;
let pigImg;
let playerImg;
let surfaceCaveImg;
let undergroundCaveImg;
let ironImg;
let coalImg;
let deathSFX;

function preload(){
  grassImg = loadImage("grass.png");
  treeImg = loadImage("Tree2 (1).png");
  plankImg = loadImage("plank.jpg");
  gravelImg = loadImage("gravel.png");
  stoneImg = loadImage("stone.png");
  dirtBGImg = loadImage("dirtBackground.jpg");
  logoImg = loadImage("MINECRAFT.png");
  woodenFloorImg = loadImage("woodenFloor.png");
  stoneBrickImg = loadImage("stoneBrick.png");
  pigImg = loadImage("pig.jpg");
  playerImg = loadImage("player.jpg");
  surfaceCaveImg = loadImage("surfaceCave.png");
  undergroundCaveImg = loadImage("undergroundCave.png");
  coalImg = loadImage("coal.png");
  ironImg = loadImage("iron.png");

  ambientBGM = loadSound("Collect_Ambient_BGM.wav");
  woodWalkSFX1 = loadSound("woodWalk1.wav");
  woodWalkSFX2 = loadSound("woodWalk2.wav");
  stoneWalkSFX1 = loadSound("stoneWalk1.wav");
  stoneWalkSFX2 = loadSound("stoneWalk2.wav");
  grassWalkSFX1 = loadSound("grassWalk1.wav");
  grassWalkSFX2 = loadSound("grassWalk2.wav");
  woodySFX = loadSound("woodySFX.mp3");
  stoneySFX = loadSound("stoneySFX.mp3");
  clickSFX = loadSound("minecraft_click.mp3");
  deathSFX = loadSound("fireHurtSFX.mp3");
} //Defines the variables as the image/sound they're supposed to represent.

function setup() {
  createCanvas(windowWidth, windowHeight);
  textFont("Garamond");
  //When started, generates a grid the size of the windowWidth and with GRID_SIZE tiles across.
  grid = generateRandomGrid(GRID_SIZE, GRID_SIZE);
  cellSize = height/grid.length;
}

function draw() {
  if (startMenuState === true) {
    //draws the background
    minecraftBackground();
    //draws start button
    displayStartButton();
    //draws tutorial button
    displayTutorialButton();
  }
  else {
  background(220);
  //Draws grid.
  displayGrid();
  //draws inventory.
  displayInventory();
  //checks if the player changes z-level.
  changeLayer(zLevel);
  //Spawns trees.
  spawnTree();
  //you'll never guess
  displayCraftingMenu();
  //Checks if the player is in the vicinity of a workshop.
  workshopCrafting();
  //Spawns pigs.
  spawnPigs();
  
    for (let i = 0; i<pigs.length; i++){
      pigs[i].die();
      if (pigs[i] != undefined){
        pigs[i].passiveMovement();
      }
    }
    for (let i = 0; i < pigs.length; i++){
      pigs[i].pigNumber = i;
    }
  
  //moves the ID point of the pigs on the grid.
  movePigs();
  //Displays the y coordinate (according to the player), otherwise known as the z coordinate (in the code)
  displayZYCoord();
  //If the bug happens where there are somehow more than one player tiles on the grid, destroys the
  //"skinwalker" tile: the one not associated with the player object variable.
  skinWalkerDestroyer();

  if (playerDeathState === true){
    //Displays the death message after you fall in lava.
    displayDeathMessage();
  }
}
}


function displayGrid() {

  //Establishes variables later used to draw the block highlights.
  let bottomLeftCorner = {
    x: 0,
    y: 0
  }
  let topLeftCorner = {
    x: 0,
    y: 0
  }
  let bottomRightCorner = {
    x: 0,
    y: 0
  }
  let topRightCorner = {
    x: 0,
    y: 0
  }

  //iterates through every tile.
  let imageOrColour = "colour";
  for (let y = 0; y<grid.length; y++){
    for (let x = 0; x<grid[2].length; x++){
      //Checks tile ID for each and colours them accordingly.
      
      
      if (grid[y][x] === 1){
        imageOrColour = "image";
        image(stoneImg, x * cellSize, y * cellSize, cellSize, cellSize);
      } //Stone ^^
      else if (grid[y][x] === PLAYER){
        imageOrColour = "image";
        image(playerImg, x * cellSize, y * cellSize, cellSize, cellSize);
      } //Player ^^
      else if (grid[y][x] === FLOOR_HOLE_TILE){
        imageOrColour = "image";
        if (zLevel === 32) {
          image(surfaceCaveImg, x * cellSize, y * cellSize, cellSize, cellSize);
        }
        else {
          image(undergroundCaveImg, x * cellSize, y * cellSize, cellSize, cellSize);
        }
      } //Floor Cave ^^
      else if (grid[y][x] === CIELING_HOLE_TILE){
        imageOrColour = "image";
        image(gravelImg, x * cellSize, y * cellSize, cellSize, cellSize);
        noStroke();
        fill(255,255,255,80);
        circle(x*cellSize+cellSize/2, y*cellSize+cellSize/2, cellSize/2);
        stroke(30);
      } //Cieling Cave ^^
      else if (grid[y][x] === TREE){
        imageOrColour = "image";
        image(treeImg, x * cellSize, y * cellSize, cellSize, cellSize);
      } //Tree^^
      else if (grid[y][x] === LAVA){
        fill("maroon");
      } //Lava^^
      else if (grid[y][x] === PLANK){
        imageOrColour = "image";
        image(plankImg, x * cellSize, y * cellSize, cellSize, cellSize);
      } //Wooden Planks ^^
      else if (grid[y][x] === COAL){
        imageOrColour = "image";
        image(coalImg, x * cellSize, y * cellSize, cellSize, cellSize);
      } //Coal ^^
      else if (grid[y][x] === IRON){
        noStroke()
        image(ironImg, x * cellSize, y * cellSize, cellSize, cellSize);
        fill(0,0,0,100);
        
      } //Iron ^^ (shaded to fit with stone texture)
      else if (grid[y][x] === WORKSHOP){
        fill("brown");
      }
      else if (grid[y][x] === PIG){
        imageOrColour = "image";
        image(pigImg, x * cellSize, y * cellSize, cellSize, cellSize);
      } //Pig ^^
      else if (grid[y][x] === WOODEN_FLOOR) {
        imageOrColour = "image";
        image(woodenFloorImg, x * cellSize, y * cellSize, cellSize, cellSize);
      } //Wooden Floor ^^
      else if (grid[y][x] === STONE_BRICKS) {
        imageOrColour = "image";
        image(stoneBrickImg, x * cellSize, y * cellSize, cellSize, cellSize);
      } //Stone bricks^^
      else {
        //Open spaces are green on zLevel 32 and white on any zLevel below.
        if (oldZ === 32){
          imageOrColour = "image";
          image(grassImg, x * cellSize, y * cellSize, cellSize, cellSize);
        }
        else{
          imageOrColour = "image";
          image(gravelImg, x * cellSize, y * cellSize, cellSize, cellSize);
        }
      }
       //Makes tiles tile-shaped.
        if (imageOrColour === "colour"){
          square(x*cellSize,y*cellSize, cellSize);
          stroke(30);
        }
        //Resets imageOrColour to the default of colouring a block instead of replacing it with an
        //image.
       imageOrColour = "colour";

       //Creates outline on block if the mouse goes over it.
      
       if (mouseX > x*cellSize &&
          mouseX < x*cellSize + cellSize &&
          mouseY > y*cellSize &&
          mouseY < y*cellSize + cellSize &&
          dist(player.x*cellSize+cellSize/2, player.y*cellSize+cellSize/2, mouseX, mouseY) < cellSize*4) {
          
            
              topLeftCorner.x = x*cellSize;
              topLeftCorner.y = y*cellSize;
            

           
              topRightCorner.x = x*cellSize + cellSize;
              topRightCorner.y = y*cellSize;
            

            
              bottomLeftCorner.x = x*cellSize;
              bottomLeftCorner.y = y*cellSize + cellSize;
            

            
              bottomRightCorner.x = x*cellSize + cellSize;
              bottomRightCorner.y = y*cellSize + cellSize;
            
            
          }
      
      
    }
  }
  //Outlines a block. Has to be at the end of the function to make it show properly. Although in hindsight,
  //I could've just made a square instead of using all of these aspects in the object variable.
  stroke("white");
  line(topLeftCorner.x, topLeftCorner.y, topRightCorner.x, topRightCorner.y);
  line(topLeftCorner.x, topLeftCorner.y, bottomLeftCorner.x, bottomLeftCorner.y);
  line(bottomRightCorner.x, bottomRightCorner.y, bottomLeftCorner.x, bottomLeftCorner.y);
  line(bottomRightCorner.x, bottomRightCorner.y, topRightCorner.x, topRightCorner.y);
  stroke("black");
}

//Generates a new grid upon entrance into floor cave or spawn in.
function generateRandomGrid(rows, cols){
  //empty array
  let emptyArray = [];
  for (let y = 0; y < rows; y++){
    //empty 2D array. Nts that the directions for x and y are conventionally swapped (x is vertical, y is horizontal).
    emptyArray.push([])
    //generates every tile in row (technically columns). Rows and cols arguments are based on const GRID_SIZE.
    for (let x = 0; x < cols; x++){
      //Checks for any coordinate locations generated by previous iterations of generateRandomGrid().
      for(let i = 0; i< cols; i++){
        if (oldCielingHoleLocationX[i] === x && oldCielingHoleLocationY[i] === y){
          //Cieling hole where coordinates are located.
          emptyArray[y].push(3);
        }
      }
        //Assuming there's no cieling holes in the tile...
        if (random(100)< 50 && oldZ < 32){
            emptyArray[y].push(1);
          } //Then have a 50% chance of pushing stone below oldZ 32.
        else if (floor(random(75)) === 1 && zLevel > 0){
          //Have a one in 75 chance of generating a floor hole.
          emptyArray[y].push(2);
          //Saves the coordinates of the floor hole for future cieling hole, theoretically in the same position (small bug that
          //sometimes generates cieling holes one off from where they're supposed to be.)
          newCielingHoleLocationX.push(emptyArray[y].length-1);
          newCielingHoleLocationY.push(emptyArray.length-1);
        }
        else if (oldZ === 32 && floor(random(75)) === 1) {
          //If on surface, have a one in 75 chance of generating a tree.
          emptyArray[y].push(TREE);
        }
        else if (oldZ < 25 && random(100) < 10+(20-oldZ)) {
          //If below Z: 25, generate lava. Amount of lava generated depends on how deep you go.
          emptyArray[y].push(LAVA);
        }
        else if (oldZ < 31 && oldZ >= 20 && (random(50)) > 47.5 + (oldZ/15)) {
          //If below Z: 31, generate coal and more the further down you go
          emptyArray[y].push(COAL);
        } 
        else if (oldZ < 27 && (random(50)) > 48 + (oldZ/20)) {
          //If below Z: 27, generate iron and more the further you descend.
          emptyArray[y].push(IRON);
        }
        else {
          //If none of the above apply, generate an empty tile.
            emptyArray[y].push(0);
        }
    }

  }
  //If its generating the grid in the setup function, then set the top left tile to be the player, overriding any other tile.
 if (grid === undefined){
  emptyArray[0][0] = 9;
 }
 //Cycles variables
  oldCielingHoleLocationX = newCielingHoleLocationX;
  oldCielingHoleLocationY = newCielingHoleLocationY;
  newCielingHoleLocationX = [];
  newCielingHoleLocationY = [];

//Returns the random grid.
  return emptyArray;
}

function mousePressed(){
  //Checks through every tile.
    for (let y = 0; y < grid.length; y++){
      for(let x = 0; x < grid[y].length; x++){
        //Checks if mouse is on the tile the nested loop is currently on, and if the distance from the player to the tile is
        //less than 3.5 tiles
        if (
          mouseX > x*cellSize &&
          mouseX < x*cellSize + cellSize &&
          mouseY > y*cellSize &&
          mouseY < y*cellSize + cellSize &&
          dist(player.x*cellSize+cellSize/2, player.y*cellSize+cellSize/2, mouseX, mouseY) < cellSize*4
          ) {
            //If it is, then...
            if (grid[y][x] === 1 && inventory.woodenPickaxeCollected>0){
              grid[y].splice(x, 1, 0);
              inventory.stoneCollected++;
              stoneySFX.play();
            } //If the tile is stone, add one stone to inventory and replace with empty tile ^^.
            else if (grid[y][x] === 9){
              dummy = -dummy;
            } ///If the tile is the player, do nothing.
            else if (grid[y][x] === 2){
              dummy = -dummy;
            } //If the tile is a floor hole, do nothing.
            else if (grid[y][x] === 3){
              dummy = -dummy;
            } //If the tile is a cieling hole, do nothing.
            else if (grid[y][x] === TREE){
              grid[y].splice(x, 1, 0);
              inventory.logsCollected += 4;
              woodySFX.play();
            }  //If the tile is a tree, add 1 logs/planks to inventory and replace with empty tile.
            else if (grid[y][x] === PLANK){
              grid[y][x] = 0;
              inventory.logsCollected++;
              woodySFX.play();
             } //If the tile is a log/plank, add 1 log/plank to inventory and replace with empty tile.
             else if (grid[y][x] === WORKSHOP){
              grid[y][x] = 0;
              inventory.workshopsCollected++;
              for (i = 0; i < workshops.length; i++){
                if (y*cellSize === workshops[i].workShopY && 
                  x*cellSize === workshops[i].workShopX && 
                  oldZ === workshops[i].workShopZ) {
                  workshops.splice(workshops[i], 1);
                  workshopCraft = false;
                }
              }
              woodySFX.play();
             } //If the tile is a workshop, add 1 workshop to inventory and replace with empty tile. Also
             //remove the workshop that you deleted from the array and set your crafting ability to basic
             //to properly facilitate the block update.
             else if (grid[y][x] === COAL && inventory.stonePickaxeCollected>0){
              grid[y][x] = 0;
              inventory.coalCollected++;
              stoneySFX.play();
             } //If the tile is coal, add 1 coal to inventory and replace with empty tile.
             else if (grid[y][x] === IRON && inventory.stonePickaxeCollected>0){
              grid[y][x] = 0;
              inventory.ironOreCollected++;
              stoneySFX.play();
             } //If the tile is iron ore, add 1 iron ore to inventory and replace with empty tile.
             else if (grid[y][x] === PIG) {
              for (let i = 0; i<pigs.length; i++){
                if (pigs[i].y === y && pigs[i].x === x) {
                  pigs[i].panickedMovement = true;
                  if (inventory.ironSwordCollected > 0) {
                    pigs[i].health = pigs[i].health - 7;
                  }
                  else if (inventory.stoneSwordCollected > 0) {
                    pigs[i].health = pigs[i].health - 5;
                  }
                  else {
                    pigs[i].health--;
                  }
                  if (pigs[i].health <= 0) {
                    pigs[i].deathState = true;
                    inventory.porkCollected = inventory.porkCollected + 1 + floor(random(2));
                  
                  }
                }
              }
              
             }
             else if (grid[y][x] === WOODEN_FLOOR) {
              grid[y][x] = OPEN_TILE;
              inventory.woodenFlooringCollected++;
              woodySFX.play();
             } //If destroy wooden floor, then collect and replace with open tile
             else if (grid[y][x] === STONE_BRICKS) {
              grid[y][x] = OPEN_TILE;
              inventory.stoneBricksCollected++;
              stoneySFX.play();
             } //If destroy stone bricks, then collect and replace with open tile
        
             
            
            else if (grid[y][x] === 0){
              if (blockSelected != undefined){
                if (blockSelected === 1 && inventory.stoneCollected>0){
                  grid[y].splice(x, 1, STONE);
                  inventory.stoneCollected--;
                  stoneySFX.play();
                } //If the tile is empty and the block selected in the inventory is stone and you have it, replace with stone, -1 stone.
                if (blockSelected === PLANK && inventory.logsCollected>0){
                  grid[y][x] = PLANK;
                  inventory.logsCollected--;
                  woodySFX.play();
                } //If the tile is empty and the block selected in the inventory is logs and you have it, replace with log, -1 log.
                if (blockSelected === WORKSHOP && inventory.workshopsCollected>0){
                  grid[y][x] = WORKSHOP;
                  inventory.workshopsCollected--;
                  
                  let newWorkshop = {
                    workShopY: y*cellSize,
                    workShopX: x*cellSize,
                    workShopZ: oldZ
                  }

                  workshops.push(newWorkshop);
                  woodySFX.play();
                } //If the tile is empty and blockSelected = workshop and you have it in inventory, push a
                //new workshop to the array and record its location. Replace the open tile with a workshop and
                //subtract one workshop from the Player's inventory.
                if (blockSelected === COAL && inventory.coalCollected>0){
                  grid[y][x] = COAL;
                  inventory.coalCollected--;
                  stoneySFX.play();
                } //If this tile is empty and the block selected is coal, replace the empty tile with coal, -1 coal.
                if (blockSelected === IRON && inventory.ironOreCollected>0){
                  grid[y][x] = IRON;
                  inventory.ironOreCollected--;
                  stoneySFX.play();
                } //If this tile is empty and the block selected is iron ore, replace the empty tile with iron ore, -1 iron ore.
                if (blockSelected === WOODEN_FLOOR && inventory.woodenFlooringCollected>0){
                  grid[y][x] = WOODEN_FLOOR;
                  inventory.woodenFlooringCollected--;
                  woodySFX.play();
                } //If this tile is empty and the block selected is wooden flooring, replace the empty tile with flooring, -1 flooring.
                if (blockSelected === STONE_BRICKS && inventory.stoneBricksCollected>0){
                  grid[y][x] = STONE_BRICKS;
                  inventory.stoneBricksCollected--;
                  stoneySFX.play();
                } //If this tile is empty and the block selected is stone bricks, replace the empty tile with stone bricks, -1 stone bricks.
              }
              else {
                dummy = -dummy;
              } //If no block is selected, do nothing.
              
            }
          }
      }
    }
    //If the mouse is in the x-spot where the inventory is...
    if(menuState === "open"){
      if (mouseX>width-width/4 && mouseX<width-width/4+100){
        //checks the y position.
        for (let y = 0; y<height; y++){
          //And if the mouseY is equal to the place iterated through with the loop...
          if(mouseY === y){
            //then choose the inventory slot you want to choose from. Remember that the inventory slot number does not correspond to
            //the block ID. Might rewrite it to fit for future convenience.
            let slot = Math.floor(y/10);
            if (slot === 0){
              //First slot is stone.
              blockSelected = STONE;
            }
            else if (slot === 1){
              //Second slot is logs/planks.
              blockSelected = PLANK;
            }
            else if (slot === 2){
              //Third slot is wooden pickaxe.
              craftingState = "Wooden Pickaxe";
            }
            else if (slot === 3) {
              //Fourth slot is workshop.
              craftingState = "Workshop";
              blockSelected = WORKSHOP;
            }
            else if (slot === 4){
              //Fifth slot is stone pickaxe.
              craftingState = "Stone Pickaxe";
            }
            else if (slot === 5){
              //Sixth slot is stone sword.
              craftingState = "Stone Sword";
            }
            else if (slot === 6){
              //etc. No need to be redundant.
              blockSelected = COAL;
            }
            else if (slot === 7){
              blockSelected = IRON;
            }
            else if (slot === 8) {
              craftingState = "Iron Ingot";
            }
            else if (slot === 10) {
              craftingState = "Iron Sword";
            }
            else if (slot === 12) {
              craftingState = "Wooden Flooring";
              blockSelected = WOODEN_FLOOR;
            }
            else if (slot === 13) {
              craftingState = "Stone Brick";
              blockSelected = STONE_BRICKS;
            }
            else if (slot === lastSlot) {
              menuState = "closed";
              craftingState = "None";
            }
            else if (slot > lastSlot) {
              craftingState = "None";
            }
          }
        }
      }  
    }

  craftSomething();
  if (mouseX>width-width/4 && mouseX<width-width/4+100 && mouseY<10 && menuState === "closed"){
    menuState = "open";
  }
  startMenu();

  //If screen clicked during the deathstate, return to regular gamestate.
  if(playerDeathState === true){
    playerDeathState = false;
  }
    
}   
  

 


 function keyPressed(){
  if (startMenuState === false && playerDeathState === false) {

    if (key === "z"){    //random grid for fun
      grid = generateRandomGrid(GRID_SIZE, GRID_SIZE);
    }
  
    if (key === "w") {   //up
      movePlayer(player.x + 0, player.y - 1); //0 on x axis, -1 on y axis
    }

    if (key === "s") {   //down
      movePlayer(player.x + 0, player.y + 1); //0 on x axis, 1 on y axis
    }

    if (key === "d") {   //right
      movePlayer(player.x + 1, player.y + 0); //1 on x axis, 0 on y axis
    }

    if (key === "a") {   //left
      movePlayer(player.x - 1, player.y + 0); //-1 on x axis, 0 on y axis
    }
  }
}


function movePlayer(x, y) {
    //don't move off the grid, and only move into open tiles
    if (x < GRID_SIZE && y < GRID_SIZE &&
        x >= 0 && y >= 0 && grid[y][x] === OPEN_TILE) {
        //previous player location
        let oldX = player.x;
        let oldY = player.y;
 
        //move the player
        player.x = x;
        player.y = y;
 
        //reset old location to be the tile it was before
        if (grid[oldY][oldX] === CIELING_HOLE_TILE){
          grid[oldY][oldX] = CIELING_HOLE_TILE;
        }
        else if (grid[oldY][oldX] === FLOOR_HOLE_TILE){
          grid[oldY][oldX] = FLOOR_HOLE_TILE;
        }
        
        else {
          if (tileState === "open tile") {
            grid[oldY][oldX] = OPEN_TILE;
          }
          else {
            grid[oldY][oldX] = WOODEN_FLOOR;
            tileState = "open tile";
          }
          
        }
       
        if (zLevel === 32) {
          let choice = random(2);
          if (choice >= 1){
            grassWalkSFX1.play();
          }
          else {
            grassWalkSFX2.play();
          }
        }
        else {
          let choice = random(2);
          if (choice >= 1){
            stoneWalkSFX1.play();
          }
          else {
            stoneWalkSFX2.play();
          }
        }
        //move the player to the new spot
        grid[player.y][player.x] = PLAYER;


    }
    if (x < GRID_SIZE && y < GRID_SIZE &&
      x >= 0 && y >= 0 && grid[y][x] === FLOOR_HOLE_TILE) {
      //previous player location
      let oldX = player.x;
      let oldY = player.y;


      //move the player
      player.x = x;
      player.y = y;


      //reset old location to be an empty tile
      if(tileState === "open tile") {
        grid[oldY][oldX] = OPEN_TILE;
      }
      else {
        grid[oldX][oldY] = WOODEN_FLOOR;
        tileState = "open tile";
      }
     
      grid[player.y][player.x] = FLOOR_HOLE_TILE;
     
      //Go down on 3D grid
      zLevel = zLevel - 1;
 }
 if (x < GRID_SIZE && y < GRID_SIZE &&
  x >= 0 && y >= 0 && grid[y][x] === CIELING_HOLE_TILE) {
  //previous player location
  let oldX = player.x;
  let oldY = player.y;


  //move the player
  player.x = x;
  player.y = y;


  //reset old location to be an empty tile
  if(tileState === "open tile") {
    grid[oldY][oldX] = OPEN_TILE;
  }
  else {
    grid[oldX][oldY] = WOODEN_FLOOR;
    tileState = "open tile"
  }
  

  grid[player.y][player.x] = CIELING_HOLE_TILE;

  //Go up on 3D grid.
  zLevel = zLevel + 1;
}
if (x < GRID_SIZE && y < GRID_SIZE &&
  x >= 0 && y >= 0 && grid[y][x] === WOODEN_FLOOR) {
  //previous player location
  let oldX = player.x;
  let oldY = player.y;


  //move the player
  player.x = x;
  player.y = y;

  //reset old location to be the tile it was before
  if (grid[oldY][oldX] === CIELING_HOLE_TILE){
    grid[oldY][oldX] = CIELING_HOLE_TILE;
  }
  else if (grid[oldY][oldX] === FLOOR_HOLE_TILE){
    grid[oldY][oldX] = FLOOR_HOLE_TILE;
  }
  else {
    if(tileState === "flooring") {
      grid[oldY][oldX] = WOODEN_FLOOR;
    }
    else {
      grid[oldY][oldX] = OPEN_TILE;
      tileState = "flooring";
    }
    
  }
  let choice = random(2);
  if (choice >= 1){
    woodWalkSFX1.play();
  }
  else {
    woodWalkSFX2.play();
  }
  //move the player to the new spot
  grid[player.y][player.x] = PLAYER;


}
if (x < GRID_SIZE && y < GRID_SIZE &&
  x >= 0 && y >= 0 && grid[y][x] === LAVA) {
  //previous player location
  let oldX = player.x;
  let oldY = player.y;

  //move the player
  player.x = x;
  player.y = y;

  //reset old location to be the tile it was before
  if (grid[oldY][oldX] === CIELING_HOLE_TILE){
    grid[oldY][oldX] = CIELING_HOLE_TILE;
  }
  else if (grid[oldY][oldX] === FLOOR_HOLE_TILE){
    grid[oldY][oldX] = FLOOR_HOLE_TILE;
  }
  
  else {
    if (tileState === "open tile") {
      grid[oldY][oldX] = OPEN_TILE;
    }
    else {
      grid[oldY][oldX] = WOODEN_FLOOR;
      tileState = "open tile";
    }
    
  }
 
  deathSFX.play();
  
  //move the player to the new spot
  
  //Death sequence: resets player location to oldGrid[32][0][0] and deletes inventory
  oldGrid[zLevel] = grid;
  oldZ = 32;
  zLevel = 32;
  grid = oldGrid[32];
  grid[0][0] = PLAYER;
  player.x = 0;
  player.y = 0;
  playerDeathState = true;
  inventory = emptyInventory;


}
}



 function changeLayer(level) {
  //Checks if the player goes down a level.
  if (level < oldZ){
    //Saves the old grid to the 3D array, goes to next grid.
    oldGrid[oldZ] = grid;
    oldZ--;
    //When loading the next grid, checks the array to see if the grid has ever been generated before.
    if (oldGrid[level] === undefined){
      //If not, generates a grid for the player to go to.
      grid = generateRandomGrid(GRID_SIZE, GRID_SIZE);
    }
    else {
      //If so, uses the grid associated with the current z-position of the player.
      grid = oldGrid[level];
    }
  }
  else if (level > oldZ){
    //If going up, then load the previous grid.
    oldGrid[oldZ] = grid;
    oldZ++;
    grid = oldGrid[level];
  }
 
 }

 //Displays the inventory.
 function displayInventory() {
  if(menuState === "open"){
    stroke(30);
    
    for (let i = 0; i<width/6; i+= 10) {
      fill("white");
      rect(width-width/4, i, 100, 10);
      if (mouseX > width-width/4 &&
          mouseX < (width-width/4) + 100 &&
          mouseY > i &&
          mouseY < i + 10
      ) {
        fill("silver");
        rect(width-width/4, i, 100, 10);
      }
      if (i > width/6-10) {
      lastSlot = Math.floor(i/10);
      fill("black");
      rect(width-width/4, i, 100, 10);
      fill("white");
      text("CLOSE", width-width/4+30, i+10);
      }
    }
   
    fill("black");
    text("Stone: "+inventory.stoneCollected, width-width/4+2, 10);
    text("Wood Planks: "+inventory.logsCollected, width-width/4+2, 20);
    text("Work Stations: "+inventory.workshopsCollected, width-width/4+2, 40);
    text("Wooden Pick: "+inventory.woodenPickaxeCollected, width-width/4+2, 30);
    text("Stone Pick: "+inventory.stonePickaxeCollected, width-width/4+2, 50);
    text("Stone Sword: "+inventory.stoneSwordCollected, width-width/4+2, 60);
    text("Coal: "+inventory.coalCollected, width-width/4+2, 70);
    text("Iron Ore: "+inventory.ironOreCollected, width-width/4+2, 80);
    text("Iron Ingots: "+inventory.ironCollected, width-width/4+2, 90);
    text("Iron Pick: "+inventory.ironPickaxeCollected, width-width/4+2, 100);
    text("Iron Sword: "+inventory.ironSwordCollected, width-width/4+2, 110);
    text("Iron Armor: "+inventory.ironArmorCollected, width-width/4+2, 120);
    text("Wood Floor: "+inventory.woodenFlooringCollected, width-width/4+2, 130);
    text("Stone Bricks: "+inventory.stoneBricksCollected, width-width/4+2, 140);
    text("Raw Pork: "+inventory.porkCollected, width-width/4+2, 150);
  
    
    
  }
  else{
    stroke(30);
    fill("black");
    rect(width-width/4, 0, 100, 10);
    fill("white");
    text("INVENTORY", width-width/4+12, 10);
  }
 


 }

 function spawnTree() {
  //counts how many trees are on the grid
  let counter = 0;
  for (let y = 0; y<grid.length; y++){
    for (let x = 0; x<grid[y].length; x++){
      if (grid[y][x] === TREE){
        counter++;
      }
  }}
  //Checks if there are less than ten trees, if you're on the surface, and if the last time it spawned a tree is more than
  //40 seconds ago.
  if (counter < MAX_TREES && zLevel === 32 && millis() > timePassed.trees+TREE_SR) {
    //if so, choose a location for a tree to spawn at
    let treeLocationX = floor(random(GRID_SIZE))
    let treeLocationY = floor(random(GRID_SIZE))
    let treeLocation = grid[treeLocationY][treeLocationX];
    //checks if the tile is open, if so spawns a tree and resets the spawn counter.
    if (treeLocation === OPEN_TILE) {
      grid[treeLocationY][treeLocationX] = TREE;
      timePassed.trees = millis();
    }
  }
 }

 function displayCraftingMenu(){
  //Checks the crafting state
  if (menuState === "open"){
  if (craftingState != "None"){
    stroke(30);
    fill("white");
    rect(width-width/4-110, 10, 100, 100);
  }
  if (craftingState === "Wooden Pickaxe"){
    fill("black");
    text("Recipe:", width-width/4-108, 22);
    text("- 5 Wood Planks", width-width/4-108, 42);
    if (inventory.logsCollected >= 5){
      fill("#d3d3d3");
      rect(width-width/4-100, 70, 80, 30);
      fill("brown");
      textSize(20);
      stroke(10);
      text("CRAFT", width-width/4-92, 90);
      textSize(12);
      stroke(30);

      if (mouseX >= width-width/4-100 && 
        mouseX <= width-width/4-20 &&
        mouseY >= 70 &&
        mouseY <= 100
      ){
        fill("silver");
        rect(width-width/4-100, 70, 80, 30);
        fill("brown");
        textSize(20);
        stroke(10);
        text("CRAFT", width-width/4-92, 90)
        textSize(12);
        stroke(30);
    }
    }
  }
  else if (craftingState === "Workshop") {
    fill("black");
    text("Recipe:", width-width/4-108, 22);
    text("- 5 Wood Planks \n- 5 Stone", width-width/4-108, 42);
    if (inventory.logsCollected >= 5 && inventory.stoneCollected >= 5){
      fill("#d3d3d3");
      rect(width-width/4-100, 70, 80, 30);
      fill("brown");
      textSize(20);
      stroke(10);
      text("CRAFT", width-width/4-92, 90);
      textSize(12);
      stroke(30);

      if (mouseX >= width-width/4-100 && 
        mouseX <= width-width/4-20 &&
        mouseY >= 70 &&
        mouseY <= 100
      ){
        fill("silver");
        rect(width-width/4-100, 70, 80, 30);
        fill("brown");
        textSize(20);
        stroke(10);
        text("CRAFT", width-width/4-92, 90)
        textSize(12);
        stroke(30);
    }
    }
  }
  else if (craftingState === "Stone Pickaxe") {
    fill("black");
    text("Recipe:", width-width/4-108, 22);
    text(`- 2 Wood Planks 
- 5 Stone
- Workshop`, width-width/4-108, 37);
    if (inventory.logsCollected >= 2 && 
      inventory.stoneCollected >= 5 &&
      workshopCraft === true){
      fill("#d3d3d3");
      rect(width-width/4-100, 70, 80, 30);
      fill("brown");
      textSize(20);
      stroke(10);
      text("CRAFT", width-width/4-92, 90);
      textSize(12);
      stroke(30);

      if (mouseX >= width-width/4-100 && 
        mouseX <= width-width/4-20 &&
        mouseY >= 70 &&
        mouseY <= 100
      ){
        fill("silver");
        rect(width-width/4-100, 70, 80, 30);
        fill("brown");
        textSize(20);
        stroke(10);
        text("CRAFT", width-width/4-92, 90)
        textSize(12);
        stroke(30);
    }
    }
  }
  else if (craftingState === "Stone Sword") {
    fill("black");
    text("Recipe:", width-width/4-108, 22);
    text(`- 2 Wood Planks 
- 7 Stone
- Workshop`, width-width/4-108, 37);
    if (inventory.logsCollected >= 2 && 
      inventory.stoneCollected >= 7 &&
      workshopCraft === true){
      fill("#d3d3d3");
      rect(width-width/4-100, 70, 80, 30);
      fill("brown");
      textSize(20);
      stroke(10);
      text("CRAFT", width-width/4-92, 90);
      textSize(12);
      stroke(30);

      if (mouseX >= width-width/4-100 && 
        mouseX <= width-width/4-20 &&
        mouseY >= 70 &&
        mouseY <= 100
      ){
        fill("silver");
        rect(width-width/4-100, 70, 80, 30);
        fill("brown");
        textSize(20);
        stroke(10);
        text("CRAFT", width-width/4-92, 90)
        textSize(12);
        stroke(30);
    }
    }
  }
  else if (craftingState === "Iron Ingot") {
    fill("black");
    text("Recipe:", width-width/4-108, 22);
    text(`- 1 Coal 
- 1 Iron Ore
- Workshop`, width-width/4-108, 37);
    if (inventory.coalCollected >= 1 && 
      inventory.ironOreCollected >= 1 &&
      workshopCraft === true){
      fill("#d3d3d3");
      rect(width-width/4-100, 70, 80, 30);
      fill("brown");
      textSize(20);
      stroke(10);
      text("CRAFT", width-width/4-92, 90);
      textSize(12);
      stroke(30);

      if (mouseX >= width-width/4-100 && 
        mouseX <= width-width/4-20 &&
        mouseY >= 70 &&
        mouseY <= 100
      ){
        fill("silver");
        rect(width-width/4-100, 70, 80, 30);
        fill("brown");
        textSize(20);
        stroke(10);
        text("CRAFT", width-width/4-92, 90)
        textSize(12);
        stroke(30);
    }
    }
  }
  else if (craftingState === "Iron Sword") {
    fill("black");
    text("Recipe:", width-width/4-108, 22);
    text(`- 2 Wood Planks 
- 7 Iron Ingots
- Workshop`, width-width/4-108, 37);
    if (inventory.logsCollected >= 2 && 
      inventory.ironCollected >= 7 &&
      workshopCraft === true){
      fill("#d3d3d3");
      rect(width-width/4-100, 70, 80, 30);
      fill("brown");
      textSize(20);
      stroke(10);
      text("CRAFT", width-width/4-92, 90);
      textSize(12);
      stroke(30);

      if (mouseX >= width-width/4-100 && 
        mouseX <= width-width/4-20 &&
        mouseY >= 70 &&
        mouseY <= 100
      ){
        fill("silver");
        rect(width-width/4-100, 70, 80, 30);
        fill("brown");
        textSize(20);
        stroke(10);
        text("CRAFT", width-width/4-92, 90)
        textSize(12);
        stroke(30);
    }
    }
  }
  else if (craftingState === "Wooden Flooring") {
    fill("black");
    text("Recipe:", width-width/4-108, 22);
    text(`- 4 Wood Planks 
- Workshop`, width-width/4-108, 42);
    if (inventory.logsCollected >= 4 && 
      workshopCraft === true){
      fill("#d3d3d3");
      rect(width-width/4-100, 70, 80, 30);
      fill("brown");
      textSize(20);
      stroke(10);
      text("CRAFT", width-width/4-92, 90);
      textSize(12);
      stroke(30);

      if (mouseX >= width-width/4-100 && 
        mouseX <= width-width/4-20 &&
        mouseY >= 70 &&
        mouseY <= 100
      ){
        fill("silver");
        rect(width-width/4-100, 70, 80, 30);
        fill("brown");
        textSize(20);
        stroke(10);
        text("CRAFT", width-width/4-92, 90)
        textSize(12);
        stroke(30);
    }
    }
  }
  else if (craftingState === "Stone Brick") {
    fill("black");
    text("Recipe:", width-width/4-108, 22);
    text(`- 4 Stone 
- Workshop`, width-width/4-108, 42);
    if (inventory.stoneCollected >= 4 && 
      workshopCraft === true){
      fill("#d3d3d3");
      rect(width-width/4-100, 70, 80, 30);
      fill("brown");
      textSize(20);
      stroke(10);
      text("CRAFT", width-width/4-92, 90);
      textSize(12);
      stroke(30);

      if (mouseX >= width-width/4-100 && 
        mouseX <= width-width/4-20 &&
        mouseY >= 70 &&
        mouseY <= 100
      ){
        fill("silver");
        rect(width-width/4-100, 70, 80, 30);
        fill("brown");
        textSize(20);
        stroke(10);
        text("CRAFT", width-width/4-92, 90)
        textSize(12);
        stroke(30);
    }
    }
  }
  }
  }
 

 function craftSomething() {
  if (mouseX >= width-width/4-100 && 
  mouseX <= width-width/4-20 &&
  mouseY >= 70 &&
  mouseY <= 100 &&
  inventory.logsCollected >= 5 &&
  craftingState === "Wooden Pickaxe"
){
  inventory.woodenPickaxeCollected++;
  inventory.logsCollected -= 5;
}
if (mouseX >= width-width/4-100 && 
  mouseX <= width-width/4-20 &&
  mouseY >= 70 &&
  mouseY <= 100 &&
  inventory.logsCollected >= 5 && 
  inventory.stoneCollected >= 5 &&
  craftingState === "Workshop"
){
  inventory.workshopsCollected++;
  inventory.logsCollected -= 5;
  inventory.stoneCollected -= 5;
}
if (mouseX >= width-width/4-100 && 
  mouseX <= width-width/4-20 &&
  mouseY >= 70 &&
  mouseY <= 100 &&
  inventory.logsCollected >= 2 && 
  inventory.stoneCollected >= 5 &&
  craftingState === "Stone Pickaxe" &&
  workshopCraft === true
){
  inventory.stonePickaxeCollected++;
  inventory.logsCollected -= 2;
  inventory.stoneCollected -= 5;
}
if (mouseX >= width-width/4-100 && 
  mouseX <= width-width/4-20 &&
  mouseY >= 70 &&
  mouseY <= 100 &&
  inventory.logsCollected >= 2 && 
  inventory.stoneCollected >= 5 &&
  craftingState === "Stone Sword" &&
  workshopCraft === true
){
  inventory.stoneSwordCollected++;
  inventory.logsCollected -= 2;
  inventory.stoneCollected -= 7;
}
if (mouseX >= width-width/4-100 && 
  mouseX <= width-width/4-20 &&
  mouseY >= 70 &&
  mouseY <= 100 &&
  inventory.coalCollected >= 1 && 
  inventory.ironOreCollected >= 1 &&
  craftingState === "Iron Ingot" &&
  workshopCraft === true
){
  inventory.ironCollected++;
  inventory.coalCollected--;
  inventory.ironOreCollected--;
}
if (mouseX >= width-width/4-100 && 
  mouseX <= width-width/4-20 &&
  mouseY >= 70 &&
  mouseY <= 100 &&
  inventory.logsCollected >= 2 && 
  inventory.ironCollected >= 5 &&
  craftingState === "Iron Sword" &&
  workshopCraft === true
){
  inventory.ironSwordCollected++;
  inventory.logsCollected -= 2;
  inventory.ironCollected -= 7;
}
if (mouseX >= width-width/4-100 && 
  mouseX <= width-width/4-20 &&
  mouseY >= 70 &&
  mouseY <= 100 &&
  inventory.logsCollected >= 4 &&
  craftingState === "Wooden Flooring" &&
  workshopCraft === true
){
  inventory.woodenFlooringCollected += 4;
  inventory.logsCollected -= 4;
}
if (mouseX >= width-width/4-100 && 
  mouseX <= width-width/4-20 &&
  mouseY >= 70 &&
  mouseY <= 100 &&
  inventory.stoneCollected >= 4 &&
  craftingState === "Stone Brick" &&
  workshopCraft === true
){
  inventory.stoneBricksCollected += 4;
  inventory.stoneCollected -= 4;
}
}

function workshopCrafting() {
  for (let i = 0; i<workshops.length; i++) {
    if (dist(player.x*cellSize+cellSize/2, player.y*cellSize+cellSize/2, workshops[i].workShopX, workshops[i].workShopY) < cellSize*4 &&
      workshops[i].workShopZ === oldZ) {
      workshopCraft = true;
    }
    else {
      workshopCraft = false;
    }
  }
}

function spawnPigs(){
  if (pigs.length <= MAX_PIGS){
  let aPig = new Pig(floor(random(GRID_SIZE)), floor(random(GRID_SIZE)), pigs.length);
  if (grid[aPig.y][aPig.x] === 0 && 
    zLevel === 32 && 
    millis() > timePassed.pigs + PIG_SR ){
      pigs.push(aPig);
      timePassed.pigs = timePassed.pigs + PIG_SR;
  }
  if (pigs.length === 3) {
    timePassed.pigs = millis();
  }
}
}

function movePigs() {
  for (i = 0; i<pigs.length; i++){
    if (pigs[i] != undefined) {
      if (pigs[i].x < GRID_SIZE && pigs[i].y < GRID_SIZE &&
        pigs[i].x >= 0 && pigs[i].y >= 0 && grid[pigs[i].y][pigs[i].x] === OPEN_TILE && zLevel === 32) {
        //previous pig location
        let oldX = pigs[i].oldX;
        let oldY = pigs[i].oldY;
  
        //reset old location to be the tile it was before
        grid[oldY][oldX] = OPEN_TILE;
        pigs[i].oldY = pigs[i].y;
        pigs[i].oldX = pigs[i].x;

        for (let x = 0; x < GRID_SIZE; x++){
          for (let y = 0; y < GRID_SIZE; y++){
            
              if (pigs[i].x === x && pigs[i].y === y ){
                grid[y][x] = PIG;
              }
            
          }
        }
    }
    
  
}
  }
}

function displayStartButton() {
  stroke(50);
  if (mouseX < width/20+300 &&
    mouseX > width/20 &&
    mouseY < height/6+100 &&
    mouseY > height/6
  ) {
    fill(255,255,255,70);
  }
  else {
    fill(255,255,255,30);
  }
  rect(width/20, height/6, 300, 100);
  
  stroke("black");
  textSize(40);
  fill("white");
  text("Start Game", width/20 + 60, height/6+height/10);
}

function minecraftBackground() {
  image(dirtBGImg, dirtBGImg.width*0, 0, dirtBGImg.width, dirtBGImg.height);
  image(dirtBGImg, dirtBGImg.width*1, 0, dirtBGImg.width, dirtBGImg.height);
  image(dirtBGImg, dirtBGImg.width*2, 0, dirtBGImg.width, dirtBGImg.height);
  image(dirtBGImg, dirtBGImg.width*3, 0, dirtBGImg.width, dirtBGImg.height);
  image(dirtBGImg, dirtBGImg.width*0, dirtBGImg.height, dirtBGImg.width, dirtBGImg.height);
  image(dirtBGImg, dirtBGImg.width*1, dirtBGImg.height, dirtBGImg.width, dirtBGImg.height);
  image(dirtBGImg, dirtBGImg.width*2, dirtBGImg.height, dirtBGImg.width, dirtBGImg.height);
  image(dirtBGImg, dirtBGImg.width*3, dirtBGImg.height, dirtBGImg.width, dirtBGImg.height);
  fill(0,0,0,100);
  rect(0,0,width,height);
  image(logoImg, width/3-width/24, height/3, logoImg.width*2, logoImg.height*2);
  fill("black");
}

function displayTutorialButton() {
  stroke(50);
  if (mouseX < width/20+300 &&
    mouseX > width/20 &&
    mouseY < height/3+height/12+100 &&
    mouseY > height/3+height/12
  ) {
    fill(255,255,255,70);
  }
  else {
    fill(255,255,255,30);
  }
  rect(width/20, height/3+height/12, 300, 100);
  
  stroke("black");
  textSize(40);
  fill("white");
  text("How to Play", width/20 + 50, height/3+height/12+height/10);
}

function startMenu() {
  if (mouseX < width/20+300 &&
    mouseX > width/20 &&
    mouseY < height/6+100 &&
    mouseY > height/6 && startMenuState === true
  ) {
    clickSFX.play();
    startMenuState = false; 
    textSize(12);
    ambientBGM.loop();
    outputVolume(0.2);
    
    
  }
  if (mouseX < width/20+300 &&
    mouseX > width/20 &&
    mouseY < height/3+height/12+100 &&
    mouseY > height/3+height/12 && startMenuState === true
  ) {
  clickSFX.play();
  writer = createWriter("TUTORIAL.txt");
    writer.write([
      `HOW TO PLAY:
      Use the WASD keys to move.
      To choose a block to place, click on the corresponding box in the inventory.
      Then to place a block, click on a place on the grid where the white outline shows.
      Note that you cannot place all items in your inventory. There are seven that you can place:

      - Stone
      - Wooden Planks
      - Workshops/Work Stations
      - Coal
      - Iron Ore
      - Wooden flooring
      - Stone Bricks

      You will also notice a y-level on the side of the building grid. Go to:

      - Y = 31 for coal.
      - Y = 26 for iron.
      - Y = 24 for lava.

      Pigs have seven health. Your fist does one damage, a stone sword does five damage, and an iron sword does seven damage.

      You can only mine coal and iron with a stone pickaxe.
      If you fall in the lava, you die and lose all of your stuff. Be careful!
      
      That being said, I hope you enjoy my game.`
    ]);
    writer.close();
  }
}

function displayZYCoord() {
  fill("red");
  textSize(16);
  text("Y Level: " + zLevel, width/2, 15);
  textSize(12);
  fill("black");
}

function displayDeathMessage() {
  fill(0, 0, 0, 100);
  rect(0, 0, width, height);
  fill("white");
  rect(width/3, height/3, 300, 100);
  fill("black");
  textSize(14);
  textAlign(CENTER);
  text(`PLAYER took a hot bath
(You lost your stuff. Click anywhere to continue.)`, width/3+150, height/3+50);
  textAlign(LEFT);
  textSize(12);
  fill("black");
}
function skinWalkerDestroyer() {
  let counter = 0;
  for (let x = 0; x<GRID_SIZE; x++) {
    for (let y = 0; y<GRID_SIZE; y++) {
      if (grid[y][x] === PLAYER) {
        counter++;
      }
      if (counter>1){
        for (let i = 0; i<GRID_SIZE; i++) {
          for (let j = 0; j<GRID_SIZE; j++) {
            if (grid[j][i] === PLAYER && player.y !== j && player.x !== i) {
              grid[j][i] = 0;
            }
          }
        }
      }
    }
  }
}