// Unnamed Topdown Survival (alpha 0.02)
// Brayden Griffith
// Date
//3/5/2024 (d/m/y)
// Extra for Experts:
// - I use a three-dimensional array called oldGrid that I use to store 32 2D arrays.
// - I use "undefined" as boolean value in if statements to check properties.



//the grid currently displayed
let grid;

//dependent on const GRID_SIZE
let cellSize;

//the block that the player is currently holding. Identified by block ID.
let blockSelected;

//dummy variable so that if statements don't throw an error by being empty. It's called "dummy" because it's a dummy variable.
let dummy = true;

//Tracks the z-level the player is on/going to
let zLevel = 32;
//Tracks the z-level the player is on/used to be on (until the new grid loads)
let oldZ = 32;

let timePassed = 0;

//inventory
let stoneCollected = 0;
let logsCollected = 0;

//for later...

// let porkCollected = 0;
// let porkchopCollected = 0;
// let burntFleshCollected = 0;
// let fleshCollected = 0;
// let ironOreCollected = 0;
// let ironCollected = 0;
// let goldOreCollected = 0;
// let goldCollected = 0;
// let adamantiumOreCollected = 0;
// let adamantiumCollected = 0;
// let coalCollected = 0;
// let workshopsCollected = 0;
// let doorsCollected = 0;
// let spikesCollected = 0;
// let woodenSwordCollected = 0;
// let woodenPickaxeCollected = 0;
// let stoneSwordCollected = 0;
// let stonePickaxeCollected = 0;
// let ironPickaxeCollected = 0;
// let ironSwordCollected = 0;
// let ironArmorCollected = 0;
// let adamantiumPickaxeCollected = 0;
// let adamantiumSwordCollected = 0;
// let adamantiumArmorCollected = 0;
// let amuletCollected = 0;
// let crucibleCollected = 0;

//Arrays storing coordinates of where cieling holes should be AFTER floor holes are generated on the layer above it.
//while generating grid, it uses the oldCielingHoleLocationX and Y arrays to check for holes generated by previous layer.
//newCielingHoleLocationX and Y are the variables that hold the new values generated by the layer, turns into old version at the end
//of the function.
let oldCielingHoleLocationX = [];
let oldCielingHoleLocationY = [];
let newCielingHoleLocationX = [];
let newCielingHoleLocationY = [];
let oldGrid = [];

//How many tiles across the grid is
const GRID_SIZE = 30;

//Rest are block IDs
const PLAYER = 9;
const OPEN_TILE = 0;
const STONE = 1;
const FLOOR_HOLE_TILE = 2;
const CIELING_HOLE_TILE = 3;
const PLANK = 4;
const TREE = 5;



const PIG = 6;
const ONI = 7;
const GOBLIN = 8;
const IRON = 10;
const GOLD = 11;
const ADAM = 12;
const COAL = 13;
const WORKSHOP = 14;
const DOOR = 15;
const LAVA = 16;

// const SPIKES = 17;
const TREE_SR = 40000;
const MAX_TREES = 10;

let player = {
  x: 0,
  y: 0,
};

// some day...

// let pig = {
//   x: 0,
//   y: 0,
//   healthPoints: 7,
//   strength: 0
// }
// let goblin = {
//   x: 0,
//   y: 0,
//   healthPoints: 20,
//   strength: 2
// }
// let oni = {
//   x: 0,
//   y: 0,
//   healthPoints: 100,
//   strength: 10,
//   necrosingStrength: 2
// }


function setup() {
  createCanvas(windowWidth, windowHeight);
  //When started, generates a grid the size of the windowWidth and with GRID_SIZE tiles across.
  grid = generateRandomGrid(GRID_SIZE, GRID_SIZE);
  cellSize = height/grid.length;
}

function draw() {
  background(220);
  //Draws grid.
  displayGrid();
  //draws inventory.
  displayInventory();
  //checks if the player changes z-level.
  changeLayer(zLevel);
  //Spawns trees
  spawnTree();
}


function displayGrid() {
  //iterates through every tile.
  for (let y = 0; y<grid.length; y++){
    for (let x = 0; x<grid[2].length; x++){
      //Checks tile ID for each and colours them accordingly.
      
      if (grid[y][x] === 1){
        fill("black");
      } //Stone ^^
      else if (grid[y][x] === 9){
        fill("red");
      } //Player ^^
      else if (grid[y][x] === 2){
        fill("gray");
      } //Floor Cave ^^
      else if (grid[y][x] === 3){
        fill("silver");
      } //Cieling Cave ^^
      else if (grid[y][x] === TREE){
        fill("lime");
      }
      else if (grid[y][x] === LAVA){
        fill("maroon");
      }
      else if (grid[y][x] === PLANK){
        fill("brown");
      } //Wooden Planks ^^
      else {
        //Open spaces are green on zLevel 32 and white on any zLevel below.
        if (oldZ === 32){
          fill("green");
        }
        else{
          fill("white");
        }
      }
       //Makes tiles tile-shaped.
      square(x*cellSize,y*cellSize, cellSize);
    }
  }
}

//Generates a new grid upon entrance into floor cave or spawn in.
function generateRandomGrid(rows, cols){
  //empty array
  let emptyArray = [];
  for (let y = 0; y < rows; y++){
    //empty 2D array. Nts that the directions for x and y are conventionally swapped (x is vertical, y is horizontal).
    emptyArray.push([])
    //generates every tile in row (technically columns). Rows and cols arguments are based on const GRID_SIZE.
    for (let x = 0; x < cols; x++){
      //Checks for any coordinate locations generated by previous iterations of generateRandomGrid().
      for(let i = 0; i< cols; i++){
        if (oldCielingHoleLocationX[i] === x && oldCielingHoleLocationY[i] === y){
          //Cieling hole where coordinates are located.
          emptyArray[y].push(3);
        }
      }
        //Assuming there's no cieling holes in the tile...
        if (random(100)< 50 && oldZ < 32){
            emptyArray[y].push(1);
          } //Then have a 50% chance of pushing stone below oldZ 32.
        else if (floor(random(75)) === 1 && zLevel > 0){
          //Have a one in 75 chance of generating a floor hole.
          emptyArray[y].push(2);
          //Saves the coordinates of the floor hole for future cieling hole, theoretically in the same position (small bug that
          //sometimes generates cieling holes one off from where they're supposed to be.)
          newCielingHoleLocationX.push(emptyArray[y].length-1);
          newCielingHoleLocationY.push(emptyArray.length-1);
        }
        else if (oldZ === 32 && floor(random(75)) === 1) {
          //If on surface, have a one in 75 chance of generating a tree.
          emptyArray[y].push(TREE);
        }
        else if (oldZ < 20 && floor(random(100)) < 10+(20-oldZ)) {
          //If below Z: 20, generate lava. Amount of lava generated depends on how deep you go.
          emptyArray[y].push(LAVA);
        }
        else {
          //If none of the above apply, generate an empty tile.
            emptyArray[y].push(0);
        }
    }

  }
  //If its generating the grid in the setup function, then set the top left tile to be the player, overriding any other tile.
 if (grid === undefined){
  emptyArray[0][0] = 9;
 }
 //Cycles variables
  oldCielingHoleLocationX = newCielingHoleLocationX;
  oldCielingHoleLocationY = newCielingHoleLocationY;
  newCielingHoleLocationX = [];
  newCielingHoleLocationY = [];

//Returns the random grid.
  return emptyArray;
}

function mousePressed(){
  //Checks through every tile.
    for (let y = 0; y < grid.length; y++){
      for(let x = 0; x < grid[y].length; x++){
        //Checks if mouse is on the tile the nested loop is currently on.
        if (
          mouseX > x*cellSize &&
          mouseX < x*cellSize + cellSize &&
          mouseY > y*cellSize &&
          mouseY < y*cellSize + cellSize
          ) {
            //If it is, then...
            if (grid[y][x] === 1){
              grid[y].splice(x, 1, 0);
              stoneCollected++;
            } //If the tile is stone, add one stone to inventory and replace with empty tile.
            else if (grid[y][x] === 9){
              dummy = -dummy;
            } ///If the tile is the player, do nothing.
            else if (grid[y][x] === 2){
              dummy = -dummy;
            } //If the tile is a floor hole, do nothing.
            else if (grid[y][x] === 3){
              dummy = -dummy;
            } //If the tile is a cieling hole, do nothing.
            else if (grid[y][x] === TREE){
              grid[y].splice(x, 1, 0);
              logsCollected = logsCollected + 5;
            }  //If the tile is a tree, add 5 logs/planks to inventory and replace with empty tile.
            else if (grid[y][x] === PLANK){
              grid[y][x] = 0;
              logsCollected++;
             } //If the tile is a log/plank, add 1 log/plank to inventory and replace with empty tile
            
            else if (grid[y][x] === 0){
              if (blockSelected != undefined){
                if(blockSelected === 1 && stoneCollected>0){
                  grid[y].splice(x, 1, STONE);
                  stoneCollected--;
                } //If the tile is empty and the block selected in the inventory is stone and you have it, replace with stone, -1 stone.
                if(blockSelected === PLANK && logsCollected>0){
                  grid[y][x] = PLANK;
                  logsCollected--;
                } //If the tile is empty and the block selected in the inventory is logs and you have it, replace with log, -1 log.
              }
              else {
                dummy = -dummy;
              } //If no block is selected, do nothing.
              
            }
          }
      }
    }
    //If the mouse is in the x-spot where the inventory is...
    if (mouseX>width-width/4 && mouseX<width-width/4+100){
      //checks the y position.
      for (let y = 0; y<height; y++){
        //And if the mouseY is equal to the place iterated through with the loop...
        if(mouseY === y){
          //then choose the inventory slot you want to choose from. Remember that the inventory slot number does not correspond to
          //the block ID. Might rewrite it to fit for future convenience.
          let slot = Math.floor(y/10);
          if (slot === 0){
            //First slot is stone.
            blockSelected = STONE;
          }
          else if (slot === 1){
            //Second slot is logs/planks.
            blockSelected = PLANK;
          }
        }
      }
    }
 }


 function keyPressed(){

  if (key === "z"){    //random grid for fun
    grid = generateRandomGrid(GRID_SIZE, GRID_SIZE);
  }
  
  if (key === "w") {   //up
    movePlayer(player.x + 0, player.y - 1); //0 on x axis, -1 on y axis
  }

  if (key === "s") {   //down
    movePlayer(player.x + 0, player.y + 1); //0 on x axis, 1 on y axis
  }

  if (key === "d") {   //right
    movePlayer(player.x + 1, player.y + 0); //1 on x axis, 0 on y axis
  }

  if (key === "a") {   //left
    movePlayer(player.x - 1, player.y + 0); //-1 on x axis, 0 on y axis
  }
}


function movePlayer(x, y) {
    //don't move off the grid, and only move into open tiles
    if (x < GRID_SIZE && y < GRID_SIZE &&
        x >= 0 && y >= 0 && grid[y][x] === OPEN_TILE) {
        //previous player location
        let oldX = player.x;
        let oldY = player.y;
 
        //move the player
        player.x = x;
        player.y = y;
 
        //reset old location to be the tile it was before
        if (grid[oldY][oldX] === CIELING_HOLE_TILE){
          grid[oldY][oldX] = CIELING_HOLE_TILE;
        }
        else if (grid[oldY][oldX] === FLOOR_HOLE_TILE){
          grid[oldY][oldX] = FLOOR_HOLE_TILE;
        }
        else {
          grid[oldY][oldX] = OPEN_TILE;
        }
       
 
        //move the player to the new spot
        grid[player.y][player.x] = PLAYER;


    }
    if (x < GRID_SIZE && y < GRID_SIZE &&
      x >= 0 && y >= 0 && grid[y][x] === FLOOR_HOLE_TILE) {
      //previous player location
      let oldX = player.x;
      let oldY = player.y;


      //move the player
      player.x = x;
      player.y = y;


      //reset old location to be an empty tile
      grid[oldY][oldX] = OPEN_TILE;
     
      grid[player.y][player.x] = FLOOR_HOLE_TILE;
     
      //Go down on 3D grid
      zLevel = zLevel - 1;
 }
 if (x < GRID_SIZE && y < GRID_SIZE &&
  x >= 0 && y >= 0 && grid[y][x] === CIELING_HOLE_TILE) {
  //previous player location
  let oldX = player.x;
  let oldY = player.y;


  //move the player
  player.x = x;
  player.y = y;


  //reset old location to be an empty tile
  grid[oldY][oldX] = OPEN_TILE;


  grid[player.y][player.x] = CIELING_HOLE_TILE;

  //Go up on 3D grid.
  zLevel = zLevel + 1;
}
}


 function changeLayer(level) {
  //Checks if the player goes down a level.
  if (level < oldZ){
    //Saves the old grid to the 3D array, goes to next grid.
    oldGrid[oldZ] = grid;
    oldZ--;
    //When loading the next grid, checks the array to see if the grid has ever been generated before.
    if (oldGrid[level] === undefined){
      //If not, generates a grid for the player to go to.
      grid = generateRandomGrid(GRID_SIZE, GRID_SIZE);
    }
    else {
      //If so, uses the grid associated with the current z-position of the player.
      grid = oldGrid[level];
    }
  }
  else if (level > oldZ){
    //If going up, then load the previous grid.
    oldGrid[oldZ] = grid;
    oldZ++;
    grid = oldGrid[level];
  }
 
 }

 //Displays the inventory. First is stone, second is planks.
 function displayInventory() {
  stroke(30)
  fill("white");
  rect(width-width/4, 0, 100, 10);
  rect(width-width/4, 10, 100, 10);
  fill("black");
  text("Stone: "+stoneCollected, width-width/4, 10);
  text("Planks: "+logsCollected, width-width/4, 20);


 }

 function spawnTree() {
  //counts how many trees are on the grid
  let counter = 0;
  for (let y = 0; y<grid.length; y++){
    for (let x = 0; x<grid[2].length; x++){
      if (grid[y][x] === TREE){
        counter++;
      }
  }}
  //Checks if there are less than ten trees, if you're on the surface, and if the last time it spawned a tree is more than
  //40 seconds ago.
  if (counter < MAX_TREES && zLevel === 32 && millis() > timePassed+TREE_SR) {
    //if so, choose a location for a tree to spawn at
    let treeLocationX = floor(random(GRID_SIZE))
    let treeLocationY = floor(random(GRID_SIZE))
    let treeLocation = grid[treeLocationY][treeLocationX];
    //checks if the tile is open, if so spawns a tree and resets the spawn counter.
    if (treeLocation === OPEN_TILE) {
      grid[treeLocationY][treeLocationX] = TREE;
      timePassed = millis();
    }
  }
 }